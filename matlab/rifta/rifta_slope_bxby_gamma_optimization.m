function Tdg = rifta_slope_bxby_gamma_optimization(...
    Xdg, Ydg, ...
    Zx_to_remove_dg, Zy_to_remove_dg, ...
    Bx, By, ...
    dg_range, ...
    ca_range...
    )
% Optimize the gamma parameter used in the inverse filtering algorithm by
% minimizing: f(gamma) = RMS(Z_residual_ca)
% Inputs:
%           gamma0: initial guess of the gamma
%      Z_to_remove: the height to remove in the entire aperture [m]
%   Z_to_remove_dw: the height to remove in the dwell gird [m]
%                B: the BRF of the ion gun
%                d: the diameter of B
%                r: the radius of b
%             flag: 'entire' for entire aperture calculation; 'dwell' for dwell grid calculation
%% Extend Zx and Zy
temp = [Zx_to_remove_dg, fliplr(-Zx_to_remove_dg)];
temp = [temp', flipud(temp)']';
Zx = temp;

temp = [Zy_to_remove_dg, fliplr(Zy_to_remove_dg)];
temp = [temp', flipud(-temp)']';
Zy = temp;

%% Generate fx & fy
% Get the size of the extended slope matrix
[Ny, Nx] = size(Zx);
nx = 1 : Nx;
ny = 1 : Ny;

% Get the unit distance in spatial domain
dx = Xdg(1, 2) - Xdg(1, 1);
dy = Ydg(2, 1) - Ydg(1, 1);

% Get the total enlargement in spatial domain
L0X = dx * Nx;
L0Y = dy * Ny;

% Calculate the coordinate in spectral domain.
u = ((nx - 1) - Nx/2) / L0X;
v = ((ny - 1) - Ny/2) / L0Y;
[fx, fy] = meshgrid(u, v);
fx = fftshift(fx);
fy = fftshift(fy);

%% FFT of Zx, Zy and Bx, By
FZxy = fft2(Zx + 1j * Zy);
FBxy = fft2(Bx + 1j * By, Ny, Nx);
Coeffs = (1j * 2 * pi * (fx + 1j * fy));
gamma0 = max([...
    abs(Coeffs(1, 2)) / abs(FBxy(1, 2)), ...
    abs(Coeffs(2, 1)) / abs(FBxy(2, 1)), ...
    abs(Coeffs(2, 2)) / abs(FBxy(2, 2))]);

%% Find the optimized gamma
fun = @(gamma)Objective_Func(...
    gamma,...
    Zx_to_remove_dg, Zy_to_remove_dg,...
    Bx, By,...
    FZxy,...
    FBxy,...
    Coeffs,...
    dg_range, ...
    ca_range...
    );
options = optimset('TolFun', 1e-15, 'TolX', 1e-15);
gamma = fminsearch(fun, gamma0, options);

Tdg = rifta_slope_bxby_inverse_filter(...
    gamma,...
    FZxy,...
    FBxy,...
    Coeffs...
    );

end

%% Merit functions fo f(gamma)
function fGamma = Objective_Func(...
    gamma, ...
    Zx_to_remove_dw, Zy_to_remove_dw, ...
    Bx, By,...
    FZxy, ...
    FBxy, ...
    Coeffs, ...
    dw_range, ...
    ca_range...
    )

% The ca in dw range
ca_in_dw_v_s = ca_range.v_s - dw_range.v_s + 1;
ca_in_dw_u_s = ca_range.u_s - dw_range.u_s + 1;
ca_in_dw_v_e = ca_in_dw_v_s + ca_range.v_e - ca_range.v_s;
ca_in_dw_u_e = ca_in_dw_u_s + ca_range.u_e - ca_range.u_s;

% Calculate T_dw for the dwell positions
Tdg = rifta_slope_bxby_inverse_filter(...
    gamma,...
    FZxy,...
    FBxy,...
    Coeffs...
    );

% Calculate the height removal in the entire aperture
Zx_removal_dw = conv_fft_2d(Tdg, Bx);
Zy_removal_dw = conv_fft_2d(Tdg, By);

% Calculate the residual
Zx_residual_ca = Zx_to_remove_dw(ca_in_dw_v_s:ca_in_dw_v_e, ca_in_dw_u_s:ca_in_dw_u_e)...
    - Zx_removal_dw(ca_in_dw_v_s:ca_in_dw_v_e, ca_in_dw_u_s:ca_in_dw_u_e);
Zy_residual_ca = Zy_to_remove_dw(ca_in_dw_v_s:ca_in_dw_v_e, ca_in_dw_u_s:ca_in_dw_u_e)...
    - Zy_removal_dw(ca_in_dw_v_s:ca_in_dw_v_e, ca_in_dw_u_s:ca_in_dw_u_e);

fGamma = sqrt((nanstd(Zx_residual_ca(:), 1)).^2 + (nanstd(Zy_residual_ca(:), 1)).^2);
% fGamma = nanstd([Zx_residual_ca(:);Zy_residual_ca(:)], 1);
% fGamma = nanstd(Zx_residual_ca(:), 1);

end